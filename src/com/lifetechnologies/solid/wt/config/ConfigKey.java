package com.lifetechnologies.solid.wt.config;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static com.lifetechnologies.solid.wt.config.Namespace.*;

/**
 * Enumerates the configuration keys used in WT tools.
 * @author mullermw
 *
 */
public enum ConfigKey {
	QUEUE_SYS( QUEUE_SYS_NAMESPACE, "", "e", "Define the scheduling environment, should be 'pbs', 'lsf' or 'sge'", "pbs" ),
	QUEUE_SYS_QUEUE(QUEUE_SYS_NAMESPACE, "queue", "q", "Name of the scheduler queue to use", "secondary"),
	QUEUE_SYS_RESOURCE_STRING(QUEUE_SYS_NAMESPACE, "resource.string", "u", "Resource string for the scheduler submission command", "nodes=1:ppn=1,mem=${pbs.mem},vmem=${pbs.vmem}"),
	QUEUE_SYS_OPTIONS(QUEUE_SYS_NAMESPACE, "options", "a", "Additional options for the scheduler submission command", ""),
	QUEUE_SYS_NODES_TMP_DIR(QUEUE_SYS_NAMESPACE, "nodes.tmp.dir", "J", "path to a temporary folder local to each compute node", "/scratch"),
	
	WT_MAX_MEMORY_PER_JOB(WHOLE_TRANSCRIPTOME_NAMESPACE,"max.memory.per.job", "j", "max amt RAM that any one job will request (some will request less). We recommend 6.5GB for Human Genome Build 18", "6.5GB"),
	WT_MAPPING_MEMORY_REQUIREMENT_ADJUSTMENT_FACTOR(WHOLE_TRANSCRIPTOME_NAMESPACE, "memory.requirement.adjustment.factor", "n", "Adjust the calculated memory requirement by multiplying by this value.", "1"),
	WT_DELETE_INTERMEDIATE_FILES(WHOLE_TRANSCRIPTOME_NAMESPACE,"delete.intermediate.files", "d", "Delete intermediate files", "false"),
	WT_FILE_REFERENCE(WHOLE_TRANSCRIPTOME_NAMESPACE, "file.reference", "f", "path to the multi fasta file containing the reference nucleotide sequences (must be accessible on compute nodes)", null, "/data/test/reference.fa"),
	WT_OUTPUT_DIR(WHOLE_TRANSCRIPTOME_NAMESPACE,"output.dir", "o", "path to the folder where all the files generated by this tool will be found", null, "/home/myself/results/wtp/test/"),
	WT_SKIP_JOBS(WHOLE_TRANSCRIPTOME_NAMESPACE, "skip.jobs", "k", "Don't submit jobs.", "false"),
	WT_EXON_REFERENCE(WHOLE_TRANSCRIPTOME_NAMESPACE, "exon.reference", "g", "Exon reference (GTF format).", null, "/data/test/exonReference.gtf"),
	
	WT_MAPPING_TASK_SKIP_TO(MAPPING_NAMESPACE,"task.skip.to", "t", "Can be one of 'splitting', 'filtering',  'ref_partitioning', 'mapping', 'extension', 'merge'", "splitting"),
	WT_MAPPING_FILTER_MODE(MAPPING_NAMESPACE,"filter.mode", "i", "Control how the filter is applied.  ONE_OR_MORE means that a read is filtered if either read split is mapped to the filter reference.  BOTH means that a read is filtered if both splits map to the reference.  OFF means no reads are filtered.", "ONE_OR_MORE"),
	WT_MAPPING_FILTER_MISMATCHES(MAPPING_NAMESPACE,"filter.mismatches", "r", "how many mismatches are tolerated in either part of the read sequence when filtering", "2"),
	WT_MAPPING_FILTER_FILE_REFERENCE(MAPPING_NAMESPACE,"filter.file.reference", "b", "path to the multi fasta file containing nucleotide sequences that the split reads will be filtered against (must be accessible on compute nodes)", null, "/data/test/human_filter_reference.fasta"),
	WT_MAPPING_READ_LENGTH(MAPPING_NAMESPACE, "read.length", "l", "Number of colors in reads.","50"),
	WT_MAPPING_READ_MASK(MAPPING_NAMESPACE,"read.mask", "m", "Mask may be specified with a string of zeroes(0, exclude) and ones(1, include).  Mask may also be specified with a comma separated list of masked positions or position ranges.  Position start at one.  Ranges are of the format <first masked position>..<last masked position>.", "46..50"),
	WT_MAPPING_MAX_LOCI(MAPPING_NAMESPACE,"max.loci", "z", "reads with more than this number of mappings will not be reported in the output file", "10"),
	WT_MAPPING_VALID_ADJACENT_MISMATCHES_COUNT_AS_ONE(MAPPING_NAMESPACE,"valid.adjacent.mismatches.count.as.one", "v", "whether or not to count valid adjacent mismatches as one mismatch, instead of two","true"),
	WT_MAPPING_MATCH_IUB(MAPPING_NAMESPACE,"match.iub", "H", "Whether or not to count alignments to consistent IUB degenerate symbols as a match, instead of as a mismatch", "false"),
	WT_MAPPING_SPLIT_LEFT_LENGTH(MAPPING_NAMESPACE,"split.left.length", "L", "how long should the first part of the read sequence split be (have not yet tested other values)","25"),
	WT_MAPPING_SPLIT_LEFT_MISMATCHES(MAPPING_NAMESPACE,"split.left.mismatches", "E", "how many mismatches are tolerated in the first part of the read sequence when mapping to the reference (increasing this number may significantly decrease performance)", "2"),
	WT_MAPPING_SPLIT_RIGHT_LENGTH(MAPPING_NAMESPACE,"split.right.length", "R", "how long should the last part of the read sequence split be (have not yet tested other values)", "30"),
	WT_MAPPING_SPLIT_RIGHT_MISMATCHES(MAPPING_NAMESPACE,"split.right.mismatches", "I", "how many mismatches are tolerated in the last part of the read sequence when mapping to the reference (increasing this number may significantly decrease performance)", "2"),
	WT_MAPPING_SCORE_MIN(MAPPING_NAMESPACE,"score.min", "s", "minimum score required for an alignment to be reported in the final output file", "24"),
	WT_MAPPING_SCORE_UNIQUENESS_GAP(MAPPING_NAMESPACE,"score.uniqueness.gap", "G", "Identifies unique mapping reads. When a read has multiple mappings, it is unique if it has a mapping with a score that exceeds the next highest score by an amount greater than or equal to this value.", "4"),
	WT_MAPPING_FILE_READS(MAPPING_NAMESPACE, "file.reads", "A", "path to the multi-fasta file of reads in color space (must be accessible on compute nodes)", null, "/data/test/maqc.brain.first100kReads.csfasta"),
	WT_MAPPING_PENALTY_KNOWN_JUNCTION(MAPPING_NAMESPACE, "penalty.known.junction", "B", "Score penalty for mapping to an known splice junction.", "0"),
	WT_MAPPING_PENALTY_PUTATIVE_JUNCTION(MAPPING_NAMESPACE, "penalty.putative.juction", "C", "Score penalty for mapping to a putative splice junction", "1"),
	
	WT_NTR_MAX_FILE(NTR_FINDER_NAMESPACE, "max.file", "m", "Sorted Max files to use in NTR Finding.", null, "<PATH>/mapping_output/HBR.chr17_6.100k.mixed.sorted.max.merged.filtered.csfasta"),
	WT_NTR_GENOMIC_REGION(NTR_FINDER_NAMESPACE, "genomic.region", "r", "Region of the Genome to analyze.  Format: <seq_id>:<start>-<end>", ""),
	WT_NTR_TRIMMING_FRACTION(NTR_FINDER_NAMESPACE, "trimming.fraction", "t", "Trimming Fraction", "0.1"),
	WT_NTR_MIN_ALIGNMENT_SCORE(NTR_FINDER_NAMESPACE, "min.alignment.score", "s", "Minimum alignment score", "24"),
	WT_NTR_MIN_OVERLAP(NTR_FINDER_NAMESPACE, "min.overlap", "v", "Minimum Overlap for matching TR to exon.", "0.5"),
	WT_NTR_MIN_WINDOW_COVERAGE(NTR_FINDER_NAMESPACE, "min.window.coverage", "b", "Minimum coverage in the window for identifying NTRs", "0.3,0.5,1,4,10,20,40,60"),
	WT_NTR_MIN_WINDOW_SIZE(NTR_FINDER_NAMESPACE, "min.window.size", "w", " Window Sizes for NTR Finding", "25,50,75,100,125,150,200"),
	WT_NTR_MAX_PTRS_PER_MEGABASE(NTR_FINDER_NAMESPACE, "max.ptrs.per.megabase", "x", "GFF files will not be produced when the number of PTRs/megabase of reference sequence exceeds this value.", "330"),
	WT_NTR_FILE_ATR_REFERENCE(NTR_FINDER_NAMESPACE, "file.atr.reference", "g", "Annotated translated region (ATR) Reference GFF File.", null, "/data/test/exonReference.gtf"),
	
	WT_REFGENE_2_GFF_REFGENE_FILE(REFGENE_2_GFF_NAMESPACE, "file.input.refgene", "i", "Refgene input file.", null, "refGene.txt"),
	WT_REFGENE_2_GFF_FILE(REFGENE_2_GFF_NAMESPACE, "file.output.gff", "o", "GFF output file.", null, "refGene.gtf");
	
	private final String namespace;
	private final String keyName;
	private final String shortOpt;
	private final String defaultValue;
	private final String exampleValue;
	private final String description;
	private static Map<String, ConfigKey> qname2key = null;
	
	ConfigKey(String namespace, String keyName, String shortOpt, String desc, String defaultValue, String exampleValue) {
		if (namespace == null) throw new IllegalArgumentException("namespace cannot be null");
		if (keyName == null) throw new IllegalArgumentException("keyName cannot be null");
		this.namespace = namespace;
		this.keyName = keyName;
		this.shortOpt = shortOpt;
		this.description = desc == null ? "" : desc;
		this.defaultValue = defaultValue;
		this.exampleValue = exampleValue == null ? "" : exampleValue;
	}
	
	ConfigKey(String namespace, String keyName, String shortOpt, String desc, String defaultValue) {
		this(namespace, keyName, shortOpt, desc, defaultValue, defaultValue);
	}
	
	/**
	 * 
	 * @param qname The qualified name of the parameter.
	 * @return the corresponding key.
	 */
	public static ConfigKey getKeyByQName(String qname) {
		if (qname2key == null) {
			 qname2key = new HashMap<String, ConfigKey>();
			 for (ConfigKey key : ConfigKey.values())
				 qname2key.put(key.getQualifiedName(), key);
		}
		return qname2key.get(qname);
	}
	
	/**
	 * List the keys in a namespace.
	 * @param namespace to list keys in
	 * @return the keys in namespace.
	 */
	public static List<ConfigKey> getMappingKeys(String namespace) {
		List<ConfigKey> keys = new ArrayList<ConfigKey>();
		for (ConfigKey key : ConfigKey.values())
			if (key.namespace.equals(namespace))
				keys.add(key);
		return keys;
	}

	/**
	 * @return the qualified name of this key.  This is the key that appears
	 * in config files.
	 */
	public String getQualifiedName() {
		if (keyName.length() == 0)
			return namespace;
		return namespace + "." + keyName;
	}

	/**
	 * get the short command line representation of this key.
	 * @return
	 */
	public String asCommandLineShortOpt() {
		return shortOpt;
	}
	
	/**
	 * @return true if this key specifies a default value.
	 */
	public boolean hasDefault() {
		return defaultValue != null;
	}
	
	/**
	 * @return the default value of the key.
	 */
	public String getDefaultValue() {
		return defaultValue;
	}

	/**
	 * @return an example value for this key.
	 */
	public String getExampleValue() {
		return exampleValue;
	}

	/**
	 * @return a description of this key.
	 */
	public String getDescription() {
		return description;
	}
	
	/**
	 * @return the long command line option for this key.
	 */
	public String asCommandLineLongOpt() {
		String key = keyName;
		if (this.namespace.equals(QUEUE_SYS_NAMESPACE))
			key = getQualifiedName();
		return key.replaceAll("\\.", "-");
	}

}
